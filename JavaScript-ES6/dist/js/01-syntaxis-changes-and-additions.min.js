(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error("Cannot find module '"+o+"'")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
'use strict';

var _objD;

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

console.log('======================================================================', '\n  Syntax Changes & Additions', '\n======================================================================');

console.log('----------------------------------------------------------------------', '\n  Let & Block Scope', '\n----------------------------------------------------------------------');

// var, generic variable
var nameA = 'John Doe';
if (true) {
    var nameA = 'Harry Doe';
}
console.log('nameA = ' + nameA); // -> 'Harry Doe', no scope so redefined

// let, Block scoped variable
var nameB = 'John Doe';
if (true) {
    // console.log('nameB = ' + nameB); // -> Will throw error, Uncaught ReferenceError: Cannot access 'nameB' before initialization
    var _nameB = 'Harry Doe';
}
console.log('nameB = ' + nameB); // -> 'John  Doe', not redefined by inner scope

// const, constant, cannot be change
var names = ['John Doe', 'Harry Doe', 'Michael Joe'];
console.log(names);

// arrays and objects are reference types, so it's possible to change their contents (reference) 
names.push('Peter Doe');
console.log(names); // -> ["John Doe", "Harry Doe", "Michael Joe", "Peter Doe"]


console.log('----------------------------------------------------------------------', '\n  Hoisting', '\n----------------------------------------------------------------------');

age = 27; // variable initialization
console.log(age); // -> 27, will work,  as variable is being hoisted
var age; // variable declaration

// color = 'blue';
// console.log(color); // -> Will throw error, ReferenceError: Cannot access 'color' before initialization
// let color;

function doSomething() {
    myNumber = 44; // variable initialization
}

var myNumber = void 0; // variable declaration
doSomething(); // use of the variable
console.log(myNumber); // will work as var is declared before being used


console.log('----------------------------------------------------------------------', '\n  (Fat) Arrow Functions', '\n----------------------------------------------------------------------');

/* 
function  fn() {
    console.log('...logging standard function');
}
*/

// above written as a fat arrow function
var fn = function fn() {
    console.log('...logging fat arrow function');
};
fn();

// simpler version with one line of inner code
var fnB = function fnB() {
    return console.log('...logging fat arrow function');
};
fnB();

// no return keyword needed as only one statement is returned
var fnC = function fnC() {
    return '...logging without return keyword';
};
console.log(fnC());

// no need of parenthesis when just one argument is provided
var fnD = function fnD(argA) {
    return argA + 5;
};
console.log(fnD(2));

setTimeout(function () {
    return console.log('...time out fired');
}, 1000);

console.log('----------------------------------------------------------------------', '\n  (Fat) Arrow Functions and the "this" Keyword', '\n----------------------------------------------------------------------');

var myWindow = undefined;
var buttonA = document.querySelector('.js-button-01');
var buttonB = document.querySelector('.js-button-02');

var fnExampleA = function fnExampleA() {
    return console.log('is window = ' + (myWindow === undefined), 'is button = ' + (buttonA === undefined));
};
function fnExampleB() {
    console.log('is window = ' + (myWindow === this), 'is button = ' + (buttonB === this));
}

fnExampleA(); // -> Arrow function will keep its context, this will be always 'window' as is defined here
fnExampleB(); // -> Normal function will change the context of whatever element triggers it

buttonA.addEventListener('click', fnExampleA);
buttonB.addEventListener('click', fnExampleB);

console.log('----------------------------------------------------------------------', '\n  Functions and Default Parameters', '\n----------------------------------------------------------------------');

// default parameter values, applies also to fat arrow functions
function isEqual(number) {
    var compare = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

    return number === compare;
}
console.log(isEqual(0, 0)); // -> true
console.log(isEqual(10)); // -> false

function isEqualB() {
    var number = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 10;
    var compare = arguments[1];

    console.log(number); // -> 10
    console.log(compare); // -> undefined
    return number === compare;
}

console.log(isEqualB(10)); // -> false, is not replacing the default parameter, 
// 10 will be compared to undefined


console.log('----------------------------------------------------------------------', '\n  Object Literal Extensions', '\n----------------------------------------------------------------------');

// standard object declaration
var obj = {
    obj_name: 'John Doe',
    obj_age: 27
};

console.log(obj); // -> {obj_name: "John Doe", obj_age: 27}

// ES6 objects will take values from surrounding values
var obj_name = 'Jane Doe';
var obj_age = 25;

var objB = {
    obj_name: obj_name,
    obj_age: obj_age,
    greet: function greet() {
        console.log('hello ' + this.obj_name + ' ' + this.obj_age);
    }
};
console.log(objB); // {obj_name: "Jane Doe", obj_age: 25, greet: ƒ}
objB.greet();

// ES6 object methods and properties can be defined as strings
var objC = {
    'name': 'Richard Doe',
    'age': 44,
    'greet him': function greetHim() {
        console.log('hello ' + this.name + ' ' + this.age);
    }
};
console.log(objC); // -> {name: "Richard Doe", age: 44, greet him: ƒ}
objC['greet him']();

// ES6 allows to name object properties dynamically
var ageField = 'age';

var objD = (_objD = {
    'name': 'Michael Doe'
}, _defineProperty(_objD, ageField, 32), _defineProperty(_objD, 'greet him', function greetHim() {
    console.log('hello ' + this.name + ' ' + this.age);
}), _objD);
console.log(objD); // -> {name: "Michael Doe", age: 32, greet him: ƒ}
console.log(objD['age']); // -> 32
console.log(objD[ageField]); // -> 32
objD['greet him']();

console.log('----------------------------------------------------------------------', '\n  The Rest operator', '\n----------------------------------------------------------------------');

// the 'rest' operator allows to pass any number of parameters
var numbers = [1, 2, 3, 4, 5];
function sumUp() {
    for (var _len = arguments.length, toAdd = Array(_len), _key = 0; _key < _len; _key++) {
        toAdd[_key] = arguments[_key];
    }

    // '...' are 'rest' operator when used defining the parameters of a function 

    console.log(toAdd);
    var result = 0;
    for (var _i = 0; _i < toAdd.length; _i++) {
        result += toAdd[_i];
    }
    return result;
}

console.log(sumUp.apply(undefined, numbers)); // using 'spread' operator, '...' 
console.log(sumUp(10, 20, 30));

console.log('----------------------------------------------------------------------', '\n  The Spread operator', '\n----------------------------------------------------------------------');

// the 'spread' operator converts an array to a list of values
var moreNumbers = [1, 2, 3, 4, 5];
console.log(Math.max(moreNumbers)); // -> NaN, function expects a list of values, not an Array
console.log(Math.max.apply(Math, moreNumbers)); // -> 5, '...' are 'spread' operator when used sending parameters to a function 


console.log('----------------------------------------------------------------------', '\n  The for-of Loop', '\n----------------------------------------------------------------------');

// the for-of Loop is meant to be used with arrays
var testResults = [1.23, 1.10, 4.1];
var _iteratorNormalCompletion = true;
var _didIteratorError = false;
var _iteratorError = undefined;

try {
    for (var _iterator = testResults[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var restResult = _step.value;

        console.log(restResult);
    }
} catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
} finally {
    try {
        if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
        }
    } finally {
        if (_didIteratorError) {
            throw _iteratorError;
        }
    }
}

console.log('----------------------------------------------------------------------', '\n  Template Literals', '\n----------------------------------------------------------------------');

// Template Literals '``', are strings with extra features
/* 
- allows to add multiline strings
- allows to insert variable values (must be a string) into a string
- to escape expressions use '\'
*/
var anotherName = 'John Doe';
var description = '\nHello ' + (anotherName + '!!!') + '\n${anotherName + \'!!!\'}\nLorem ipsum dolor sit amet \nconsectetur adipisicing elit.\n';

console.log(description);

console.log('----------------------------------------------------------------------', '\n  Destructuring - Arrays', '\n----------------------------------------------------------------------');

var evenMoreNumbers = [1, 2, 3];

// let a = evenMoreNumbers[0];
// let b = evenMoreNumbers[1];

var a = evenMoreNumbers[0],
    b = evenMoreNumbers[1]; // same as above using ES6 destructuring

console.log(a, b); // -> 1 2

var c = evenMoreNumbers[0],
    d = evenMoreNumbers[1],
    e = evenMoreNumbers[2],
    f = evenMoreNumbers[3]; // will assign 'undefined' to non existing value

console.log(c, d, e, f); // -> 1 2 3 undefined

var g = evenMoreNumbers[0],
    h = evenMoreNumbers.slice(1); // 'rest parameter 'will take remaining values as an array, similar to slice or splice methods

console.log(g, h); // -> 1 (2) [2, 3]

var i = evenMoreNumbers[0],
    j = evenMoreNumbers[1],
    k = evenMoreNumbers[2],
    _evenMoreNumbers$ = evenMoreNumbers[3],
    l = _evenMoreNumbers$ === undefined ? 'default' : _evenMoreNumbers$; // is possible to define default values

console.log(i, j, k, l); // -> 1 2 3 "default"

var _evenMoreNumbers$2 = evenMoreNumbers[0],
    m = _evenMoreNumbers$2 === undefined ? 'default' : _evenMoreNumbers$2,
    n = evenMoreNumbers[1],
    o = evenMoreNumbers[2],
    _evenMoreNumbers$3 = evenMoreNumbers[3],
    p = _evenMoreNumbers$3 === undefined ? 'default' : _evenMoreNumbers$3; // default values are replaces in case value actually exist

console.log(m, n, o, p); // -> 1 2 3 "default"

var q = evenMoreNumbers[0],
    r = evenMoreNumbers[2]; // ignoring one value

console.log(q, r); // -> 1 3

var _ref = [1, 2, 3],
    s = _ref[0],
    t = _ref[1]; // destructuring without defining an array

console.log(s, t); // -> 1 2

// is possible to swap variable values
var varA = 1;
var varB = 2;

var _ref2 = [varA, varB];
varB = _ref2[0];
varA = _ref2[1];

console.log(varA); // -> 2
console.log(varB); // -> 1


console.log('----------------------------------------------------------------------', '\n  Destructuring - Objects', '\n----------------------------------------------------------------------');

anotherObj = {
    hisName: 'John Doe',
    hisAge: 27,
    hisGreet: function hisGreet() {
        console.log('Hello!');
    }
};

// Destructuring for Objects is done by key name, not by order as with arrays
var _anotherObj = anotherObj,
    hisName = _anotherObj.hisName,
    hisAge = _anotherObj.hisAge,
    hisGreet = _anotherObj.hisGreet; // variables names have to match key names

console.log(hisName, hisAge, hisGreet); // -> John Doe 27 ƒ hisGreet()...

var _anotherObj2 = anotherObj,
    theName = _anotherObj2.hisName,
    theGreet = _anotherObj2.hisGreet; // is possible to assign other names

console.log(theName, theGreet); // -> John Doe ƒ hisGreet()...
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZha2VfYmNjMjE3Y2QuanMiXSwibmFtZXMiOlsiY29uc29sZSIsImxvZyIsIm5hbWVBIiwibmFtZUIiLCJuYW1lcyIsInB1c2giLCJhZ2UiLCJkb1NvbWV0aGluZyIsIm15TnVtYmVyIiwiZm4iLCJmbkIiLCJmbkMiLCJmbkQiLCJhcmdBIiwic2V0VGltZW91dCIsIm15V2luZG93IiwiYnV0dG9uQSIsImRvY3VtZW50IiwicXVlcnlTZWxlY3RvciIsImJ1dHRvbkIiLCJmbkV4YW1wbGVBIiwiZm5FeGFtcGxlQiIsImFkZEV2ZW50TGlzdGVuZXIiLCJpc0VxdWFsIiwibnVtYmVyIiwiY29tcGFyZSIsImlzRXF1YWxCIiwib2JqIiwib2JqX25hbWUiLCJvYmpfYWdlIiwib2JqQiIsImdyZWV0Iiwib2JqQyIsIm5hbWUiLCJhZ2VGaWVsZCIsIm9iakQiLCJudW1iZXJzIiwic3VtVXAiLCJ0b0FkZCIsInJlc3VsdCIsImkiLCJsZW5ndGgiLCJtb3JlTnVtYmVycyIsIk1hdGgiLCJtYXgiLCJ0ZXN0UmVzdWx0cyIsInJlc3RSZXN1bHQiLCJhbm90aGVyTmFtZSIsImRlc2NyaXB0aW9uIiwiZXZlbk1vcmVOdW1iZXJzIiwiYSIsImIiLCJjIiwiZCIsImUiLCJmIiwiZyIsImgiLCJqIiwiayIsImwiLCJtIiwibiIsIm8iLCJwIiwicSIsInIiLCJzIiwidCIsInZhckEiLCJ2YXJCIiwiYW5vdGhlck9iaiIsImhpc05hbWUiLCJoaXNBZ2UiLCJoaXNHcmVldCIsInRoZU5hbWUiLCJ0aGVHcmVldCJdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUFBLFFBQVFDLEdBQVIsQ0FDSSx3RUFESixFQUVJLGdDQUZKLEVBR0ksMEVBSEo7O0FBTUFELFFBQVFDLEdBQVIsQ0FDSSx3RUFESixFQUVJLHVCQUZKLEVBR0ksMEVBSEo7O0FBTUE7QUFDQSxJQUFJQyxRQUFRLFVBQVo7QUFDQSxJQUFHLElBQUgsRUFBUztBQUNQLFFBQUlBLFFBQVEsV0FBWjtBQUNEO0FBQ0RGLFFBQVFDLEdB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QyxZQUhTLHNCQUdDO0FBQ04xRSxnQkFBUUMsR0FBUixDQUFZLFFBQVo7QUFDSDtBQUxRLENBQWI7O0FBUUE7a0JBQ2tDc0UsVTtJQUE3QkMsTyxlQUFBQSxPO0lBQVNDLE0sZUFBQUEsTTtJQUFRQyxRLGVBQUFBLFEsRUFBd0I7O0FBQzlDMUUsUUFBUUMsR0FBUixDQUFZdUUsT0FBWixFQUFxQkMsTUFBckIsRUFBNkJDLFFBQTdCLEUsQ0FBd0M7O21CQUVLSCxVO0lBQS9CSSxPLGdCQUFUSCxPO0lBQTRCSSxRLGdCQUFWRixRLEVBQWtDOztBQUN6RDFFLFFBQVFDLEdBQVIsQ0FBWTBFLE9BQVosRUFBcUJDLFFBQXJCLEUsQ0FBZ0MiLCJmaWxlIjoiZmFrZV9iY2MyMTdjZC5qcyIsInNvdXJjZXNDb250ZW50IjpbImNvbnNvbGUubG9nKFxuICAgICc9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09JyxcbiAgICAnXFxuICBTeW50YXggQ2hhbmdlcyAmIEFkZGl0aW9ucycsXG4gICAgJ1xcbj09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0nXG4pO1xuXG5jb25zb2xlLmxvZyhcbiAgICAnLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLScsXG4gICAgJ1xcbiAgTGV0ICYgQmxvY2sgU2NvcGUnLFxuICAgICdcXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tJ1xuKTtcbiBcbi8vIHZhciwgZ2VuZXJpYyB2YXJpYWJsZVxudmFyIG5hbWVBID0gJ0pvaG4gRG9lJztcbmlmKHRydWUpIHtcbiAgdmFyIG5hbWVBID0gJ0hhcnJ5IERvZSc7IFxufVxuY29uc29sZS5sb2coJ25hbWVBID0gJyArIG5hbWVBKTsgLy8gLT4gJ0hhcnJ5IERvZScsIG5vIHNjb3BlIHNvIHJlZGVmaW5lZFxuXG4vLyBsZXQsIEJsb2NrIHNjb3BlZCB2YXJpYWJsZVxubGV0IG5hbWVCID0gJ0pvaG4gRG9lJzsgXG5pZih0cnVlKSB7XG4gICAgLy8gY29uc29sZS5sb2coJ25hbWVCID0gJyArIG5hbWVCKTsgLy8gLT4gV2lsbCB0aHJvdyBlcnJvciwgVW5jYXVnaHQgUmVmZXJlbmNlRXJyb3I6IENhbm5vdCBhY2Nlc3MgJ25hbWVCJyBiZWZvcmUgaW5pdGlhbGl6YXRpb25cbiAgICBsZXQgbmFtZUIgPSAnSGFycnkgRG9lJzsgXG59XG5jb25zb2xlLmxvZygnbmFtZUIgPSAnICsgbmFtZUIpOyAvLyAtPiAnSm9obiAgRG9lJywgbm90IHJlZGVmaW5lZCBieSBpbm5lciBzY29wZVxuICBcbi8vIGNvbnN0LCBjb25zdGFudCwgY2Fubm90IGJlIGNoYW5nZVxuY29uc3QgbmFtZXMgPSBbJ0pvaG4gRG9lJywgJ0hhcnJ5IERvZScsICdNaWNoYWVsIEpvZSddO1xuY29uc29sZS5sb2cobmFtZXMpO1xuXG4vLyBhcnJheXMgYW5kIG9iamVjdHMgYXJlIHJlZmVyZW5jZSB0eXBlcywgc28gaXQncyBwb3NzaWJsZSB0byBjaGFuZ2UgdGhlaXIgY29udGVudHMgKHJlZmVyZW5jZSkgXG5uYW1lcy5wdXNoKCdQZXRlciBEb2UnKTtcbmNvbnNvbGUubG9nKG5hbWVzKTsgLy8gLT4gW1wiSm9obiBEb2VcIiwgXCJIYXJyeSBEb2VcIiwgXCJNaWNoYWVsIEpvZVwiLCBcIlBldGVyIERvZVwiXVxuXG5cbmNvbnNvbGUubG9nKFxuICAgICctLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tJyxcbiAgICAnXFxuICBIb2lzdGluZycsXG4gICAgJ1xcbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0nXG4pO1xuXG5hZ2UgPSAyNzsgICAgICAgICAgIC8vIHZhcmlhYmxlIGluaXRpYWxpemF0aW9uXG5jb25zb2xlLmxvZyhhZ2UpOyAgIC8vIC0+IDI3LCB3aWxsIHdvcmssICBhcyB2YXJpYWJsZSBpcyBiZWluZyBob2lzdGVkXG52YXIgYWdlOyAgICAgICAgICAgIC8vIHZhcmlhYmxlIGRlY2xhcmF0aW9uXG5cbi8vIGNvbG9yID0gJ2JsdWUnO1xuLy8gY29uc29sZS5sb2coY29sb3IpOyAvLyAtPiBXaWxsIHRocm93IGVycm9yLCBSZWZlcmVuY2VFcnJvcjogQ2Fubm90IGFjY2VzcyAnY29sb3InIGJlZm9yZSBpbml0aWFsaXphdGlvblxuLy8gbGV0IGNvbG9yO1xuXG5mdW5jdGlvbiBkb1NvbWV0aGluZygpIHtcbiAgICBteU51bWJlciA9IDQ0OyAgICAgIC8vIHZhcmlhYmxlIGluaXRpYWxpemF0aW9uXG59XG5cbmxldCBteU51bWJlcjsgICAgICAgICAgIC8vIHZhcmlhYmxlIGRlY2xhcmF0aW9uXG5kb1NvbWV0aGluZygpOyAgICAgICAgICAvLyB1c2Ugb2YgdGhlIHZhcmlhYmxlXG5jb25zb2xlLmxvZyhteU51bWJlcik7ICAvLyB3aWxsIHdvcmsgYXMgdmFyIGlzIGRlY2xhcmVkIGJlZm9yZSBiZWluZyB1c2VkXG5cblxuY29uc29sZS5sb2coXG4gICAgJy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0nLFxuICAgICdcXG4gIChGYXQpIEFycm93IEZ1bmN0aW9ucycsXG4gICAgJ1xcbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0nXG4pO1xuXG4vKiBcbmZ1bmN0aW9uICBmbigpIHtcbiAgICBjb25zb2xlLmxvZygnLi4ubG9nZ2luZyBzdGFuZGFyZCBmdW5jdGlvbicpO1xufVxuKi9cblxuLy8gYWJvdmUgd3JpdHRlbiBhcyBhIGZhdCBhcnJvdyBmdW5jdGlvblxuY29uc3QgZm4gPSAoKSA9PiB7XG4gICAgY29uc29sZS5sb2coJy4uLmxvZ2dpbmcgZmF0IGFycm93IGZ1bmN0aW9uJyk7XG59O1xuZm4oKTtcblxuLy8gc2ltcGxlciB2ZXJzaW9uIHdpdGggb25lIGxpbmUgb2YgaW5uZXIgY29kZVxuY29uc3QgZm5CID0gKCkgPT4gY29uc29sZS5sb2coJy4uLmxvZ2dpbmcgZmF0IGFycm93IGZ1bmN0aW9uJyk7XG5mbkIoKTtcblxuLy8gbm8gcmV0dXJuIGtleXdvcmQgbmVlZGVkIGFzIG9ubHkgb25lIHN0YXRlbWVudCBpcyByZXR1cm5lZFxuY29uc3QgZm5DID0gKCkgPT4gJy4uLmxvZ2dpbmcgd2l0aG91dCByZXR1cm4ga2V5d29yZCc7XG5jb25zb2xlLmxvZyhmbkMoKSk7IFxuXG4vLyBubyBuZWVkIG9mIHBhcmVudGhlc2lzIHdoZW4ganVzdCBvbmUgYXJndW1lbnQgaXMgcHJvdmlkZWRcbmNvbnN0IGZuRCA9IGFyZ0EgPT4gYXJnQSArIDU7XG5jb25zb2xlLmxvZyhmbkQoMikpO1xuXG5zZXRUaW1lb3V0KCgpID0+IGNvbnNvbGUubG9nKCcuLi50aW1lIG91dCBmaXJlZCcpLCAxMDAwKTtcblxuY29uc29sZS5sb2coXG4gICAgJy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0nLFxuICAgICdcXG4gIChGYXQpIEFycm93IEZ1bmN0aW9ucyBhbmQgdGhlIFwidGhpc1wiIEtleXdvcmQnLFxuICAgICdcXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tJ1xuKTtcblxubGV0IG15V2luZG93ID0gdGhpcztcbmxldCBidXR0b25BID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLmpzLWJ1dHRvbi0wMScpO1xubGV0IGJ1dHRvbkIgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuanMtYnV0dG9uLTAyJyk7XG5cbmNvbnN0IGZuRXhhbXBsZUEgPSAoKSA9PiBjb25zb2xlLmxvZygnaXMgd2luZG93ID0gJyArIChteVdpbmRvdyA9PT0gdGhpcyksICdpcyBidXR0b24gPSAnICsgKGJ1dHRvbkEgPT09IHRoaXMpKTtcbmZ1bmN0aW9uIGZuRXhhbXBsZUIoKSB7XG4gICAgY29uc29sZS5sb2coJ2lzIHdpbmRvdyA9ICcgKyAobXlXaW5kb3cgPT09IHRoaXMpLCAnaXMgYnV0dG9uID0gJyArIChidXR0b25CID09PSB0aGlzKSk7XG59XG5cbmZuRXhhbXBsZUEoKTsgLy8gLT4gQXJyb3cgZnVuY3Rpb24gd2lsbCBrZWVwIGl0cyBjb250ZXh0LCB0aGlzIHdpbGwgYmUgYWx3YXlzICd3aW5kb3cnIGFzIGlzIGRlZmluZWQgaGVyZVxuZm5FeGFtcGxlQigpOyAvLyAtPiBOb3JtYWwgZnVuY3Rpb24gd2lsbCBjaGFuZ2UgdGhlIGNvbnRleHQgb2Ygd2hhdGV2ZXIgZWxlbWVudCB0cmlnZ2VycyBpdFxuXG5idXR0b25BLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZm5FeGFtcGxlQSk7XG5idXR0b25CLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZm5FeGFtcGxlQik7XG5cbmNvbnNvbGUubG9nKFxuICAgICctLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tJyxcbiAgICAnXFxuICBGdW5jdGlvbnMgYW5kIERlZmF1bHQgUGFyYW1ldGVycycsXG4gICAgJ1xcbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0nXG4pO1xuXG4vLyBkZWZhdWx0IHBhcmFtZXRlciB2YWx1ZXMsIGFwcGxpZXMgYWxzbyB0byBmYXQgYXJyb3cgZnVuY3Rpb25zXG5mdW5jdGlvbiBpc0VxdWFsKG51bWJlciwgY29tcGFyZSA9IDApIHtcbiAgICByZXR1cm4gbnVtYmVyID09PSBjb21wYXJlO1xufVxuY29uc29sZS5sb2coaXNFcXVhbCgwICwgMCkpOyAgICAvLyAtPiB0cnVlXG5jb25zb2xlLmxvZyhpc0VxdWFsKDEwKSk7ICAgICAgIC8vIC0+IGZhbHNlXG5cbmZ1bmN0aW9uIGlzRXF1YWxCKG51bWJlciA9IDEwLCBjb21wYXJlKSB7XG4gICAgY29uc29sZS5sb2cobnVtYmVyKTsgICAgICAgIC8vIC0+IDEwXG4gICAgY29uc29sZS5sb2coY29tcGFyZSk7ICAgICAgIC8vIC0+IHVuZGVmaW5lZFxuICAgIHJldHVybiBudW1iZXIgPT09IGNvbXBhcmU7XG59XG5cbmNvbnNvbGUubG9nKGlzRXF1YWxCKDEwKSk7ICAgICAgLy8gLT4gZmFsc2UsIGlzIG5vdCByZXBsYWNpbmcgdGhlIGRlZmF1bHQgcGFyYW1ldGVyLCBcbi8vIDEwIHdpbGwgYmUgY29tcGFyZWQgdG8gdW5kZWZpbmVkXG5cblxuY29uc29sZS5sb2coXG4gICAgJy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0nLFxuICAgICdcXG4gIE9iamVjdCBMaXRlcmFsIEV4dGVuc2lvbnMnLFxuICAgICdcXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tJ1xuKTtcblxuLy8gc3RhbmRhcmQgb2JqZWN0IGRlY2xhcmF0aW9uXG5sZXQgb2JqID0ge1xuICAgIG9ial9uYW1lOiAnSm9obiBEb2UnLFxuICAgIG9ial9hZ2U6IDI3XG59XG5cbmNvbnNvbGUubG9nKG9iaik7IC8vIC0+IHtvYmpfbmFtZTogXCJKb2huIERvZVwiLCBvYmpfYWdlOiAyN31cblxuLy8gRVM2IG9iamVjdHMgd2lsbCB0YWtlIHZhbHVlcyBmcm9tIHN1cnJvdW5kaW5nIHZhbHVlc1xubGV0IG9ial9uYW1lID0gJ0phbmUgRG9lJztcbmxldCBvYmpfYWdlID0gMjU7XG5cbmxldCBvYmpCID0ge1xuICAgIG9ial9uYW1lLFxuICAgIG9ial9hZ2UsXG4gICAgZ3JlZXQoKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdoZWxsbyAnICsgdGhpcy5vYmpfbmFtZSArICcgJyArIHRoaXMub2JqX2FnZSk7XG4gICAgfVxufVxuY29uc29sZS5sb2cob2JqQik7IC8vIHtvYmpfbmFtZTogXCJKYW5lIERvZVwiLCBvYmpfYWdlOiAyNSwgZ3JlZXQ6IMaSfVxub2JqQi5ncmVldCgpO1xuXG4vLyBFUzYgb2JqZWN0IG1ldGhvZHMgYW5kIHByb3BlcnRpZXMgY2FuIGJlIGRlZmluZWQgYXMgc3RyaW5nc1xubGV0IG9iakMgPSB7XG4gICAgJ25hbWUnOiAnUmljaGFyZCBEb2UnLFxuICAgICdhZ2UnOiA0NCxcbiAgICAnZ3JlZXQgaGltJygpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ2hlbGxvICcgKyB0aGlzLm5hbWUgKyAnICcgKyB0aGlzLmFnZSk7XG4gICAgfVxufVxuY29uc29sZS5sb2cob2JqQyk7IC8vIC0+IHtuYW1lOiBcIlJpY2hhcmQgRG9lXCIsIGFnZTogNDQsIGdyZWV0IGhpbTogxpJ9XG5vYmpDWydncmVldCBoaW0nXSgpO1xuXG4vLyBFUzYgYWxsb3dzIHRvIG5hbWUgb2JqZWN0IHByb3BlcnRpZXMgZHluYW1pY2FsbHlcbmxldCBhZ2VGaWVsZCA9ICdhZ2UnO1xuXG5sZXQgb2JqRCA9IHtcbiAgICAnbmFtZSc6ICdNaWNoYWVsIERvZScsXG4gICAgW2FnZUZpZWxkXTogMzIsICAvLyBkeW5hbWljIHByb3BlcnR5IG5hbWUgYXNzaWdubWVudFxuICAgICdncmVldCBoaW0nKCkge1xuICAgICAgICBjb25zb2xlLmxvZygnaGVsbG8gJyArIHRoaXMubmFtZSArICcgJyArIHRoaXMuYWdlKTtcbiAgICB9XG59XG5jb25zb2xlLmxvZyhvYmpEKTsgLy8gLT4ge25hbWU6IFwiTWljaGFlbCBEb2VcIiwgYWdlOiAzMiwgZ3JlZXQgaGltOiDGkn1cbmNvbnNvbGUubG9nKG9iakRbJ2FnZSddKTsgICAgICAgLy8gLT4gMzJcbmNvbnNvbGUubG9nKG9iakRbYWdlRmllbGRdKTsgICAgLy8gLT4gMzJcbm9iakRbJ2dyZWV0IGhpbSddKCk7XG5cblxuY29uc29sZS5sb2coXG4gICAgJy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0nLFxuICAgICdcXG4gIFRoZSBSZXN0IG9wZXJhdG9yJyxcbiAgICAnXFxuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSdcbik7XG5cbi8vIHRoZSAncmVzdCcgb3BlcmF0b3IgYWxsb3dzIHRvIHBhc3MgYW55IG51bWJlciBvZiBwYXJhbWV0ZXJzXG5sZXQgbnVtYmVycyA9IFsxLCAyLCAzLCA0LCA1XTtcbmZ1bmN0aW9uIHN1bVVwKC4uLnRvQWRkKSB7IC8vICcuLi4nIGFyZSAncmVzdCcgb3BlcmF0b3Igd2hlbiB1c2VkIGRlZmluaW5nIHRoZSBwYXJhbWV0ZXJzIG9mIGEgZnVuY3Rpb24gXG4gICAgXG4gICAgY29uc29sZS5sb2codG9BZGQpO1xuICAgIGxldCByZXN1bHQgPSAwO1xuICAgIGZvcihsZXQgaSA9IDA7IGkgPCB0b0FkZC5sZW5ndGg7IGkrKykge1xuICAgICAgICByZXN1bHQgKz0gdG9BZGRbaV07XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5cbmNvbnNvbGUubG9nKHN1bVVwKC4uLm51bWJlcnMpKTsgLy8gdXNpbmcgJ3NwcmVhZCcgb3BlcmF0b3IsICcuLi4nIFxuY29uc29sZS5sb2coc3VtVXAoMTAsIDIwLCAzMCkpO1xuXG5jb25zb2xlLmxvZyhcbiAgICAnLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLScsXG4gICAgJ1xcbiAgVGhlIFNwcmVhZCBvcGVyYXRvcicsXG4gICAgJ1xcbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0nXG4pO1xuXG4vLyB0aGUgJ3NwcmVhZCcgb3BlcmF0b3IgY29udmVydHMgYW4gYXJyYXkgdG8gYSBsaXN0IG9mIHZhbHVlc1xubGV0IG1vcmVOdW1iZXJzID0gWzEsIDIsIDMsIDQsIDVdO1xuY29uc29sZS5sb2coTWF0aC5tYXgobW9yZU51bWJlcnMpKTsgLy8gLT4gTmFOLCBmdW5jdGlvbiBleHBlY3RzIGEgbGlzdCBvZiB2YWx1ZXMsIG5vdCBhbiBBcnJheVxuY29uc29sZS5sb2coTWF0aC5tYXgoLi4ubW9yZU51bWJlcnMpKTsgLy8gLT4gNSwgJy4uLicgYXJlICdzcHJlYWQnIG9wZXJhdG9yIHdoZW4gdXNlZCBzZW5kaW5nIHBhcmFtZXRlcnMgdG8gYSBmdW5jdGlvbiBcblxuXG5jb25zb2xlLmxvZyhcbiAgICAnLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLScsXG4gICAgJ1xcbiAgVGhlIGZvci1vZiBMb29wJyxcbiAgICAnXFxuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSdcbik7XG5cbi8vIHRoZSBmb3Itb2YgTG9vcCBpcyBtZWFudCB0byBiZSB1c2VkIHdpdGggYXJyYXlzXG5sZXQgdGVzdFJlc3VsdHMgPSBbMS4yMywgMS4xMCwgNC4xXTtcbmZvcihsZXQgcmVzdFJlc3VsdCBvZiB0ZXN0UmVzdWx0cykge1xuICAgIGNvbnNvbGUubG9nKHJlc3RSZXN1bHQpO1xufVxuXG5jb25zb2xlLmxvZyhcbiAgICAnLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLScsXG4gICAgJ1xcbiAgVGVtcGxhdGUgTGl0ZXJhbHMnLFxuICAgICdcXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tJ1xuKTtcblxuLy8gVGVtcGxhdGUgTGl0ZXJhbHMgJ2BgJywgYXJlIHN0cmluZ3Mgd2l0aCBleHRyYSBmZWF0dXJlc1xuLyogXG4tIGFsbG93cyB0byBhZGQgbXVsdGlsaW5lIHN0cmluZ3Ncbi0gYWxsb3dzIHRvIGluc2VydCB2YXJpYWJsZSB2YWx1ZXMgKG11c3QgYmUgYSBzdHJpbmcpIGludG8gYSBzdHJpbmdcbi0gdG8gZXNjYXBlIGV4cHJlc3Npb25zIHVzZSAnXFwnXG4qL1xubGV0IGFub3RoZXJOYW1lID0gJ0pvaG4gRG9lJztcbmxldCBkZXNjcmlwdGlvbiA9IGBcbkhlbGxvICR7YW5vdGhlck5hbWUgKyAnISEhJ31cblxcJHthbm90aGVyTmFtZSArICchISEnfVxuTG9yZW0gaXBzdW0gZG9sb3Igc2l0IGFtZXQgXG5jb25zZWN0ZXR1ciBhZGlwaXNpY2luZyBlbGl0LlxuYDtcblxuY29uc29sZS5sb2coZGVzY3JpcHRpb24pO1xuXG5jb25zb2xlLmxvZyhcbiAgICAnLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLScsXG4gICAgJ1xcbiAgRGVzdHJ1Y3R1cmluZyAtIEFycmF5cycsXG4gICAgJ1xcbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0nXG4pO1xuXG5sZXQgZXZlbk1vcmVOdW1iZXJzID0gWzEsIDIsIDNdO1xuXG4vLyBsZXQgYSA9IGV2ZW5Nb3JlTnVtYmVyc1swXTtcbi8vIGxldCBiID0gZXZlbk1vcmVOdW1iZXJzWzFdO1xuXG5sZXRbYSwgYl0gPSBldmVuTW9yZU51bWJlcnM7IC8vIHNhbWUgYXMgYWJvdmUgdXNpbmcgRVM2IGRlc3RydWN0dXJpbmdcbmNvbnNvbGUubG9nKGEsIGIpOyAvLyAtPiAxIDJcblxubGV0W2MsIGQsIGUsIGZdID0gZXZlbk1vcmVOdW1iZXJzOyAvLyB3aWxsIGFzc2lnbiAndW5kZWZpbmVkJyB0byBub24gZXhpc3RpbmcgdmFsdWVcbmNvbnNvbGUubG9nKGMsIGQsIGUsIGYpOyAvLyAtPiAxIDIgMyB1bmRlZmluZWRcblxubGV0W2csIC4uLmhdID0gZXZlbk1vcmVOdW1iZXJzOyAvLyAncmVzdCBwYXJhbWV0ZXIgJ3dpbGwgdGFrZSByZW1haW5pbmcgdmFsdWVzIGFzIGFuIGFycmF5LCBzaW1pbGFyIHRvIHNsaWNlIG9yIHNwbGljZSBtZXRob2RzXG5jb25zb2xlLmxvZyhnLCBoKTsgLy8gLT4gMSAoMinCoFsyLCAzXVxuXG5sZXRbaSwgaiwgaywgbCA9ICdkZWZhdWx0J10gPSBldmVuTW9yZU51bWJlcnM7IC8vIGlzIHBvc3NpYmxlIHRvIGRlZmluZSBkZWZhdWx0IHZhbHVlc1xuY29uc29sZS5sb2coaSwgaiwgaywgbCk7IC8vIC0+IDEgMiAzIFwiZGVmYXVsdFwiXG5cbmxldFttID0gJ2RlZmF1bHQnLCBuLCBvLCBwID0gJ2RlZmF1bHQnXSA9IGV2ZW5Nb3JlTnVtYmVyczsgLy8gZGVmYXVsdCB2YWx1ZXMgYXJlIHJlcGxhY2VzIGluIGNhc2UgdmFsdWUgYWN0dWFsbHkgZXhpc3RcbmNvbnNvbGUubG9nKG0sIG4sIG8sIHApOyAvLyAtPiAxIDIgMyBcImRlZmF1bHRcIlxuXG5sZXRbcSwgLCByXSA9IGV2ZW5Nb3JlTnVtYmVyczsgLy8gaWdub3Jpbmcgb25lIHZhbHVlXG5jb25zb2xlLmxvZyhxLCByKTsgLy8gLT4gMSAzXG5cbmxldFtzLCB0XSA9IFsxLCAyLCAzXTsgLy8gZGVzdHJ1Y3R1cmluZyB3aXRob3V0IGRlZmluaW5nIGFuIGFycmF5XG5jb25zb2xlLmxvZyhzLCB0KTsgLy8gLT4gMSAyXG5cbi8vIGlzIHBvc3NpYmxlIHRvIHN3YXAgdmFyaWFibGUgdmFsdWVzXG5sZXQgdmFyQSA9IDE7XG5sZXQgdmFyQiA9IDI7XG5cblt2YXJCLCB2YXJBXSA9IFt2YXJBLCB2YXJCXTtcbmNvbnNvbGUubG9nKHZhckEpOyAvLyAtPiAyXG5jb25zb2xlLmxvZyh2YXJCKTsgLy8gLT4gMVxuIFxuXG5jb25zb2xlLmxvZyhcbiAgICAnLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLScsXG4gICAgJ1xcbiAgRGVzdHJ1Y3R1cmluZyAtIE9iamVjdHMnLFxuICAgICdcXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tJ1xuKTtcblxuYW5vdGhlck9iaiA9IHtcbiAgICBoaXNOYW1lOiAnSm9obiBEb2UnLFxuICAgIGhpc0FnZTogMjcsXG4gICAgaGlzR3JlZXQoKXtcbiAgICAgICAgY29uc29sZS5sb2coJ0hlbGxvIScpO1xuICAgIH1cbn07XG5cbi8vIERlc3RydWN0dXJpbmcgZm9yIE9iamVjdHMgaXMgZG9uZSBieSBrZXkgbmFtZSwgbm90IGJ5IG9yZGVyIGFzIHdpdGggYXJyYXlzXG5sZXQge2hpc05hbWUsIGhpc0FnZSwgaGlzR3JlZXR9ID0gYW5vdGhlck9iajsgLy8gdmFyaWFibGVzIG5hbWVzIGhhdmUgdG8gbWF0Y2gga2V5IG5hbWVzXG5jb25zb2xlLmxvZyhoaXNOYW1lLCBoaXNBZ2UsIGhpc0dyZWV0KTsgLy8gLT4gSm9obiBEb2UgMjcgxpIgaGlzR3JlZXQoKS4uLlxuXG5sZXQge2hpc05hbWU6IHRoZU5hbWUsIGhpc0dyZWV0OiB0aGVHcmVldH0gPSBhbm90aGVyT2JqOyAvLyBpcyBwb3NzaWJsZSB0byBhc3NpZ24gb3RoZXIgbmFtZXNcbmNvbnNvbGUubG9nKHRoZU5hbWUsIHRoZUdyZWV0KTsgLy8gLT4gSm9obiBEb2UgxpIgaGlzR3JlZXQoKS4uLiJdfQ==
},{}]},{},[1])